### es6虽然已经看过很多次阮一峰老师的那本书了，但是很多东西都忘记了，而且当时看的时候也没有深入的理解，所以趁这个时候重新看一遍es6

#### 常用

 - let const
 - 解构
 - 模板字符串


##### let和const

在区块中，如果用let声明了一个变量，那么在声明之前该变量都是不可用的，这成为暂时性死区。

let和const声明的函数不是挂载在window上的。

##### 数组

数组解构的时候，如果默认值是表达式，但是解构的时候是有值的，那么表达式就不会执行。

在解构的时候默认值生效的条件是对象的属性值严格等于undefined（就是null不行）。

##### 数值

##### Math.sign()
Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

它会返回五种值。

- 参数为正数，返回+1；
- 参数为负数，返回-1；
- 参数为 0，返回0；
- 参数为-0，返回-0;
- 其他值，返回NaN。

#### 函数

函数参数的默认值设置。

函数的length属性代表了函数预期传入的参数的个数，如果有参数设置了默认值，那么length就会减去设置默认值的参数的个数，如果设置默认值的不是尾参数，那么设置默认值以后的参数都会计算在length中。

用rest参数获取函数的参数就可以不用指定个数。（类似于用...解构的方法，解构为一个数组）。

箭头函数的this指向指向的是定义的时候所在的作用域。

##### 尾调用
尾调用是指在函数最后调用函数。

我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。

##### 尾递归
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。